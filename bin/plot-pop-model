#!/usr/bin/env python

'PLOT-POP-MODEL -- plot population model'
__usage__ = 'plot-pop-model pop_model.csv [-p popmodel -o /path/to/plot.png -v]'
__author__ = 'Philippe Landry (pgjlandry@gmail.com)'
__date__ = '02-2021'

from argparse import ArgumentParser
import numpy as np
import numpy.random
import os
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import seaborn as sns
import sodapop.populations as pop
import videlicet.viz as viz

parser = ArgumentParser(description=__doc__)
parser.add_argument('popmodeldata')
parser.add_argument('-d', '--delim', help='delimiter for data file, DEFAULT=","', default=',')
parser.add_argument('-w', '--weightcol', help='name of posterior weight column to use, DEFAULT="weight"', default='weight')
parser.add_argument('-p', '--popmodel', help='name of population model, DEFAULT="doublegaussian_m1m2"', default="doublegaussian_m1m2", type=str)
parser.add_argument('-o', '--outpath', help='path for output population parameter samples, DEFAULT=AUTO', default=False)
parser.add_argument('-m', '--mrange', help='mass range for plot, DEFAULT="0.5 3."', default=[0.5,3.])
parser.add_argument('-n', '--nummods', help='number of population model realizations to plot, DEFAULT=100', default=100, type=float)
parser.add_argument('-b', '--binary', action='store_false', default=True)
parser.add_argument('-v', '--verbose', action='store_true', default=False)
args = parser.parse_args()

if args.outpath: out_path = args.outpath
else: out_path = os.path.dirname(args.popmodeldata)+'/'+os.path.basename(args.popmodeldata).split('.')[0]+'.png'

MMIN = args.mrange[0]
MMAX = args.mrange[1]

NUM_MODELS = int(args.nummods)

def ALPHA_FUNC(x):

	return 0.1	# return 0.1*x**100.

# load posterior samples

popdata = np.genfromtxt(args.popmodeldata, names=True, dtype=None, delimiter=args.delim, encoding=None)
param_names = pop.get_pop_params(args.popmodel).split(',')
params = np.column_stack([popdata[param_name] for param_name in param_names])
wts = popdata[args.weightcol]
wts = wts/np.sum(wts)
maxap = np.max(wts)

maxap_idx = np.where(wts == wts.max())[0][0]
maxap_params = params[maxap_idx]

idxs = np.random.choice(len(wts),size=NUM_MODELS,replace=True,p=wts)
params_out = [params[idx] for idx in idxs]

pop_like = pop.get_pop_prior(args.popmodel)
mgrid = np.arange(MMIN,MMAX,0.02)

fig, ax = plt.subplots()

if not args.binary:

	for i,param in enumerate(params_out):
		m_likes = [pop_like(m,*param) for m in mgrid]
		m_likes = m_likes/np.sum(m_likes)
		plt.plot(mgrid, m_likes, alpha=ALPHA_FUNC(wts[i]/maxap), color=sns.color_palette()[1], lw=1.)
		
	m_likes = [pop_like(m,*maxap_params) for m in mgrid]
	m_likes = m_likes/np.sum(m_likes)
	plt.plot(mgrid, m_likes, alpha=1., color=sns.color_palette()[0], lw=2.)
	
	plt.xlabel('m [M_sun]')
	viz.viz_style()
	plt.savefig(out_path)
	
else:

	for i,param in enumerate(params_out):

		m1_likes = [np.sum([pop_like(m1,m2*param) for m2 in mgrid]) for m1 in mgrid]
		m1_likes = m1_likes/np.sum(m1_likes)
		plt.plot(mgrid, m1_likes, alpha=ALPHA_FUNC(wts[i]/maxap), color=sns.color_palette()[1], lw=1.)

	m1_likes = [np.sum([pop_like(m1,m2,*maxap_params) for m2 in mgrid]) for m1 in mgrid]
	m1_likes = m1_likes/np.sum(m1_likes)
	plt.plot(mgrid, m1_likes, alpha=1., color=sns.color_palette()[0], lw=2.)

	plt.xlabel('m_1 [M_sun]')
	
	viz.viz_style()
	plt.savefig(out_path.split('.png')[0]+'-m1.png')

	fig, ax = plt.subplots()

	for i,param in enumerate(params):

		m2_likes = [np.sum([pop_like(m1,m2,*param) for m1 in mgrid]) for m2 in mgrid]
		m2_likes = m2_likes/np.sum(m2_likes)
		plt.plot(mgrid, m2_likes, alpha=ALPHA_FUNC(wts[i]/maxap), color=sns.color_palette()[1], lw=1.)

	m2_likes = [np.sum([pop_like(m1,m2,*maxap_params) for m1 in mgrid]) for m2 in mgrid]
	m2_likes = m2_likes/np.sum(m2_likes)
	plt.plot(mgrid, m2_likes, alpha=1., color=sns.color_palette()[0], lw=2.)

	plt.xlabel('m_2 [M_sun]')
	
	viz.viz_style()
	plt.savefig(out_path.split('.png')[0]+'-m2.png')

