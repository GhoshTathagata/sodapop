#!/usr/bin/env python

'SAMPLE-POP-PARAMS -- sample population model parameters'
__usage__ = 'sample-pop-params pop_model [-p param_prior_shape,hypparam1,hypparam2 param_prior_shape,hypparam1,hypparam2 ... -o /path/to/output.csv -n 1e4 -v]'
__author__ = 'Philippe Landry (pgjlandry@gmail.com)'
__date__ = '02-2021'

from argparse import ArgumentParser
import numpy as np
import os
import sodapop.populations as pop
import sodapop.parameters as params

parser = ArgumentParser(description=__doc__)
parser.add_argument('popmodel',type=str)
parser.add_argument('-d', '--delim', help='delimiter for data file, DEFAULT=","', default=',')
parser.add_argument('-n', '--numsamps', help='number of samples to draw, DEFAULT=1000', default=1000, type=float)
parser.add_argument('-p', '--priors', help='prior distribution and hyperparameters for each population parameter, DEFAULT="flat,0.,1."', default="flat,0.,1.", type=str, nargs='+')
parser.add_argument('-o', '--outpath', help='path for output reweighted samples, DEFAULT=AUTO', default=False)
parser.add_argument('-v', '--verbose', action='store_true', default=False)
args = parser.parse_args()

if args.outpath: out_path = args.outpath
else: out_path = '{0}_prior.csv'.format(args.popmodel)

num_samps = int(args.numsamps)

# get population model

param_names = pop.get_pop_params(args.popmodel).split(',')

# sample from parameter priors

samps = []
for i,param in enumerate(param_names):

	priordat = args.priors[i].split(',')
	prior_name = priordat[0]
	hypparams = priordat[1:]
	param_samps = params.get_param_samples(num_samps,prior_name,hypparams)
	samps.append(param_samps)

# ensure mmax parameter > mmin parameter and mu2 parameter > mu1 parameter

if 'mmax' in param_names and 'mmin' in param_names:

	mmaxs = samps[param_names.index('mmax')]
	mmins = samps[param_names.index('mmin')]
	
	mmaxs_out = []
	mmins_out = []
	for mmax,mmin in zip(mmaxs,mmins):
	
		mmaxs_out.append(max(mmax,mmin))
		mmins_out.append(min(mmax,mmin))

if 'mu' in param_names:

	mus = samps[param_names.index('mu')]
	
	mus_out = []
	for mu,mmin,mmax in zip(mus,mmins_out,mmaxs_out):
	
		while mu < mmin or mu > mmax:
			j = param_names.index('mu')
			mu = params.get_param_samples(1,args.priors[j].split(',')[0],args.priors[j].split(',')[1:])

		mus_out.append(mu)
		
if 'mu1' in param_names and 'mu2' in param_names:

	mu1s = samps[param_names.index('mu1')]
	mu2s = samps[param_names.index('mu2')]
	
	mu1s_out = []
	mu2s_out = []
	for mu1,mu2,mmin,mmax in zip(mu1s,mu2s,mmins_out,mmaxs_out):
	
		while mu1 < mmin or mu2 > mmax or mu1 > mu2:
			j = param_names.index('mu1')
			k = param_names.index('mu2')
			mu1 = params.get_param_samples(1,args.priors[j].split(',')[0],args.priors[j].split(',')[1:])
			mu2 = params.get_param_samples(1,args.priors[k].split(',')[0],args.priors[k].split(',')[1:])

		mu1s_out.append(min(mu1,mu2))
		mu2s_out.append(max(mu1,mu2))
		
samps_out = []
for i,param in enumerate(param_names):

	if param == 'mmax': samps_out.append(mmaxs_out)
	elif param == 'mmin': samps_out.append(mmins_out)
	elif param == 'mu': samps_out.append(mus_out)
	elif param == 'mu1': samps_out.append(mu1s_out)
	elif param == 'mu2': samps_out.append(mu2s_out)
	else: samps_out.append(samps[i])

# save parameter samples

param_samps = np.column_stack(samps_out)
col_names = pop.get_pop_params(args.popmodel)
np.savetxt(out_path,param_samps,header=col_names,comments='',delimiter=',')
