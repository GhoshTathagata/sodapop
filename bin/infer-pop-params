#!/usr/bin/env python

'INFER-POP-PARAMS -- infer population parameters based on population model and observations'
__usage__ = 'infer-pop-params pop_params.csv samples.csv [-p pop_model -o /path/to/output.csv -v]'
__author__ = 'Philippe Landry (pgjlandry@gmail.com)'
__date__ = '01-2021'

from argparse import ArgumentParser
import numpy as np
import numpy.random
import os
import sodapop.populations as pop

parser = ArgumentParser(description=__doc__)
parser.add_argument('popparams')
parser.add_argument('likedata', nargs='+')
parser.add_argument('-d', '--delim', help='delimiter for data file, DEFAULT=","', default=',')
parser.add_argument('-c', '--cols', help='name of mass1, mass2 and likelihood data columns to use, DEFAULT="m1 m2 likelihood"', default=['m1','m2','likelihood'], nargs='+')
parser.add_argument('-p', '--popmodel', help='name of population model, DEFAULT="doublegaussian_m1m2"', default="doublegaussian_m1m2", nargs='+')
parser.add_argument('-s', '--select', help='name of selection function, DEFAULT=False', default=False)
parser.add_argument('-o', '--outpath', help='path for output population parameter samples, DEFAULT=AUTO', default=False)
parser.add_argument('-v', '--verbose', action='store_true', default=False)
args = parser.parse_args()

if args.outpath: out_path = args.outpath
else: out_path = os.path.dirname(args.likedata[0])+'/'+args.popmodel[0]+'.csv'

NUM_PRIOR_SAMPS = 1e4
PRIOR_M_UPPER = 23.
PRIOR_DL_UPPER = 1000.

num_masses = len(args.cols)-1

# get population model

if len(args.popmodel) == 1: pop_probs = [pop.get_pop_prior(args.popmodel[0]) for likedata in args.likedata]
else: pop_probs = [pop.get_pop_prior(args.popmodel[i]) for i,likedata in enumerate(args.likedata)]

if args.select: select_func = pop.get_select_func(args.select)
else: select_func = lambda *x : 1.

# load likelihood samples

if args.verbose: print('Loading likelihood data...')

likesamps = []
for likedata in args.likedata:

	data = np.genfromtxt(likedata,names=True,dtype=None,delimiter=args.delim)
	cols = data.dtype.names
	if args.verbose: print(cols) # check column names; use source-frame masses
	
	wts = data[args.cols[-1]]

	if num_masses == 2:
		m1s = data[args.cols[0]] # COLUMN NAMES FOR INPUT
		m2s = data[args.cols[1]]
		samps = list(zip(m1s,m2s,wts))
	else:	
		ms = data[args.cols[0]]
		samps = list(zip(ms,wts))
	
	likesamps.append(samps)

# load same number of uniform samples

numsamps = int(NUM_PRIOR_SAMPS)
unif_m_samps1 = np.random.choice(np.arange(0.,PRIOR_M_UPPER,0.1),numsamps)
unif_m_samps2 = np.random.choice(np.arange(0.,PRIOR_M_UPPER,0.1),numsamps)
unif_dl_samps = np.random.choice(np.arange(0.,PRIOR_DL_UPPER,1.),numsamps)

if num_masses == 2: unif_samps = [[max(m1,m2),min(m1,m2),dl] for m1,m2,dl in zip(unif_m_samps1,unif_m_samps2,unif_dl_samps)]
else: unif_samps = unif_m_samps1
		
# calculate population parameter posterior

pop_params = np.genfromtxt(args.popparams, names=None, dtype=None, delimiter=args.delim, skip_header=1)

posts = []
for i,params in enumerate(pop_params):

	if args.verbose: print('Evaluating probability of population model {0}...'.format(i))

	if num_masses == 2:
		denoms = [np.sum([select_func(m1,m2,dl)*pop_probs[j](m1,m2,*params) for m1,m2,dl in unif_samps])/numsamps for j,samps in enumerate(likesamps)]
		likes = [np.sum([wt*pop_probs[j](m1,m2,*params) for m1,m2,wt in samps])/len(samps) for j,samps in enumerate(likesamps)]
	else:
		denoms = [np.sum([select_func(m)*pop_probs[j](m,*params) for m in unif_samps])/numsamps for j,samps in enumerate(likesamps)]
		likes = [np.sum([wt*pop_probs[j](m,*params) for m,wt in samps]) for j,samps in enumerate(likesamps)]
		
	likes = [like/denom for like,denom in zip(likes,denoms)]
	
	params_post = np.prod(likes)
	posts.append([params_post])

# save population parameters posterior
pop_param_samps = np.append(np.array(pop_params),np.array(posts),axis=1)
col_names = pop.get_pop_params(args.popmodel[0])+',weight' # COLUMN NAMES FOR OUTPUT
np.savetxt(out_path,pop_param_samps[~np.isfinite(pop_param_samps)],header=col_names,comments='',delimiter=',')
